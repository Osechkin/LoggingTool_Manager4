// [Main]
// Стандартная активация T2 (для тестового датчика)
// Активация позволяет получать релаксационный спад (эхо-сигнала) при таком времени ожидания (time waiting) Tw, что пластовые флюиды полностью поляризованы,
// и минимальном интервале между эхо (time between echo) Te=2*tau, при котором сводятся к минимумам эффекты диффузии на амплитуду спинового эхо.
// (Spb типичные значения при такой активации: интервал между эхо Te=1,2 мс, время ожидания 3.0 с < Tw < 6.0 с, число эхо-сигналов N=300)

main.name = "Standartd activation"
main.author = "Иванов А.А, Савинков А.В, Дорогиницкий М.М."
main.datetime = "25.03.2016 11:50"
main.description = "Стандартная активация. Последовательность Карра-Парселла-Мейбума-Гилла (КПМГ)"


// Блок констант
// [Constants]
var DDS_CLK_FRQ_HZ = 250000000 			// "Тактовая частота DDS (константа, прошита в ПЛИС)"
var IF_FRQ_HZ = 455000					// "Промежуточная частота приемника (константа, задана аппаратно)"
var NMR_SAMPLE_FREQ = 1000000			// "Частота дискретизации (константа, задана аппаратно)"

// Блок параметров для "опытного" и недоступные для "обычного" оператора
var damp_rx_always_on = 0;				// "Включить демпфирование приемника постоянно" ( значения: 0/1 )
var blank_pwr = 1;						// "БП выключение на время работы АЦП" ( значения: 0/1 )
var debug_adc = 0;						// "Отладка АЦП (0 нормальный режим, 1 подключить вместо АЦП счетчик)"



//-----------------------------------------------------------------------------------------------------------
// Блок параметров датчиков
// [Probes]

@parameter probe = { "Датчик (набор частот 0-3)", 0, min=0, max=3 }
probe.comment = "Датчик (набор частот 0-3)"

@parameter rx_adr = { "Адрес активного приемника", 0, min=0, max=3 }
rx_adr.comment = "Адрес активного приемника"

@parameter tx_adr = { "Адрес активного передатчика", 0, min=0, max=3 }
tx_adr.comment = "Адрес активного передатчика"

@parameter level = { "Уровень АЦП", 2080, min=0, max=4095 }
level.comment = "Уровень АЦП для вычитания из ВЧ сигнала перед Фурье-преобразованием"

@section s_probes = { "Probes" }
s_probes.append(probe);
s_probes.append(rx_adr);
s_probes.append(tx_adr);
s_probes.append(level);


//-----------------------------------------------------------------------------------------------------------
// Блок параметров частот
// [Frequencies]

// "Смещение частоты приема относительно заданной базовой частоты"
var adc_frq_ofs_hz = 0;
adc_frq_ofs_hz = adc_frq_ofs_hz / DDS_CLK_FRQ_HZ * 4294967296;	// Частота АЦП, Гц


@parameter tx_frq_ofs_hz = { "Частота передачи", -2000, min=-488281, max=488281, units="Гц" }
tx_frq_ofs_hz.comment = "Смещение частоты передачи относительно заданной базовой частоты"
tx_frq_ofs_hz.exec(tx_frq_ofs_hz~ / DDS_CLK_FRQ_HZ * 4294967296)

@parameter tx_frq2_ofs_hz = { "Частота передачи 2", 0, min=-488281, max=488281, units="Гц" }
tx_frq2_ofs_hz.comment = "Смещение частоты передачи 2 относительно заданной базовой частоты"
tx_frq2_ofs_hz.exec(tx_frq2_ofs_hz~ / DDS_CLK_FRQ_HZ * 4294967296)

@parameter rx_frq_ofs_hz = { "Частота приема", 10000, min=-488281, max=488281, units="Гц" }
rx_frq_ofs_hz.comment = "Смещение частоты приема относительно заданной базовой частоты"
rx_frq_ofs_hz.exec(rx_frq_ofs_hz~ / DDS_CLK_FRQ_HZ * 4294967296)

@parameter field = { "Ток подмагничивания", 0, min=-33168, max=32367, units="усл. ед." }
field.comment = "Ток подмагничивания (-32 768; +32 767)"
field.exec(field~ + 33168)

@parameter vc_dac_value = { "Варикапы, напряжение", 5000, min=0, max=65535, units="усл. ед." }
vc_dac_value.comment = "Варикапы, напряжение (усл. ед.)"

@section s_freqs = { "Frequencies" }
s_freqs.append(tx_frq_ofs_hz);
s_freqs.append(rx_frq_ofs_hz);
s_freqs.append(field);
s_freqs.append(vc_dac_value);


//-----------------------------------------------------------------------------------------------------------
// Блок длительности РЧ-импульсов
// [RF_pulses]

@parameter rf_pulse_duration_90 = { "Длительность 90<sup>0</sup> РЧ импульса", 65, min=0, max=16777215, units="мкс" }
rf_pulse_duration_90.comment = "Длительность 90<sup>0</sup> РЧ импульса"
rf_pulse_duration_90.exec(rf_pulse_duration_90~ * 10)

@parameter rf_pulse_duration_180 = { "Длительность 180<sup>0</sup> РЧ импульса", 120, min=0, max=16777215, units="мкс" }
rf_pulse_duration_180.comment = "Длительность 180<sup>0</sup> РЧ импульса"
rf_pulse_duration_180.exec(rf_pulse_duration_180~ * 10)

@section s_rf_pulses = { "RF-Pulses" }
s_rf_pulses.append(rf_pulse_duration_90);
s_rf_pulses.append(rf_pulse_duration_180);

// "Интервал до момента включения приёмника, в котором выполняются команды выключения приёмника, формирования 180-импульса и выключение импульсных источников питания"
var rf_pulse_180 = rf_pulse_duration_180~ * 10;		// "мкс"

// "Интервал до момента включения приёмника, в котором выполняются команды выключения приёмника, формирования 90-импульса и выключение импульсных источников питания"
var rf_pulse_90 = rf_pulse_duration_90~ * 10; 		// "мкс"


//-----------------------------------------------------------------------------------------------------------
// Блок настройки фаз импульсов
// [Phases]

@parameter ph_90_num = { "Код фазы 90<sup>0</sup> импульса", 0, min=0, max=360, units=" <sup>0</sup>, град." }
ph_90_num.comment = "Код фазы 90<sup>0</sup> импульса"
ph_90_num.exec(ph_90_num~ * 46603.375)

@parameter ph_180_num = { "Код фазы 180<sup>0</sup> импульса", 90, min=0, max=360, units=" <sup>0</sup>, град." }
ph_180_num.comment = "Код фазы 180<sup>0</sup> импульса относительно 90<sup>0</sup>"
ph_180_num.exec(ph_180_num~ * 46603.375)

@section s_phases = { "Phases" }
s_phases.append(ph_90_num);
s_phases.append(ph_180_num);


//-----------------------------------------------------------------------------------------------------------
// Блок счетчиков
// [Counters]

@parameter noise_windows_num = { "Число накоплений шума", 16, min=1, max=16777215 }
noise_windows_num.comment = "Число окон измерения шума"

@parameter echoes_num = { "Число окон измерений эхо", 700, min=1, max=16777215 }
echoes_num.comment = "Число окон измерений эхо"

@parameter noise_number = { "Номер окна АЦП (шум)", 1, min=1, max=100 }
noise_number.comment = "Номер окна шума перед последовательностью КПМГ для визуализации формы"

@parameter signal_number = { "Номер окна АЦП (сигнал)", 1, min=1, max=5000 }
signal_number.comment = "Номер эхо в последовательности КПМГ для визуализации формы"

@section s_counters = { "Counters" }
s_counters.append(noise_windows_num);
s_counters.append(echoes_num);
s_counters.append(noise_number);
s_counters.append(signal_number);


//-----------------------------------------------------------------------------------------------------------
// Блок временных параметров последовательности
// [Intervals]

@parameter tau = { "Интервал времени tau", 1400, min=0, max=16777215, units="мкс" }
tau.comment = "Интервал времени tau между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ"

@parameter time_of_waiting = { "Интервал между последовательностями", 3000000, min=1, max=16777215, units="мкс" }
time_of_waiting.comment = "Интервал между окончанием и началом РЧ импульсов повторяющихся последовательностей"

@parameter echo_aq_time = { "Окно АЦП", 300, min=0, max=16777215, units="мкс" }
echo_aq_time.comment = "Длительность окна АЦП для регистрации сигнала спинового эхо"
echo_aq_time.exec(echo_aq_time~ - 1)

@parameter adc_window_shift_time = { "Смещение окна АЦП", 130, min=-8388608, max=8388607, units="мкс" }
adc_window_shift_time.comment = "Смещение окна АЦП от расчетного времени"
adc_window_shift_time.exec(adc_window_shift_time~ - 1)

@parameter delay_before_rf_pulses = { "Задержка перед началом измерений", 10000, min=0, max=16777215, units="мкс" }
delay_before_rf_pulses.comment = "Задержка перед началом измерений требуется для гарантированного завершения обмена данными"
delay_before_rf_pulses.exec(delay_before_rf_pulses~ - 1)

@parameter damp_pulse_duration = { "Импульс демпфирования (длительность после РЧ)", 150, min=0, max=16777215, units="мкс" }
damp_pulse_duration.comment = "Интервал до включения АЦП, в котором включается приёмник (длительность после РЧ)"
damp_pulse_duration.exec(damp_pulse_duration~ - 1)

@parameter delay_for_strobes = { "Интервал разнесения стробов", 10, min=2, max=16777215, units="мкс" }
delay_for_strobes.comment = "Интервал для разнесения стробов обработки данных и окончания окна измерений"
delay_for_strobes.ron = true
delay_for_strobes.exec(delay_for_strobes~ - 1)

@parameter time_blank_pwr_prior_to_adc = { "Время опережения отключения БП окна АЦП", 200, min=1, max=16777215, units="мкс" }
time_blank_pwr_prior_to_adc.comment = "Время опережения отключения БП окна АЦП"
time_blank_pwr_prior_to_adc.exec(time_blank_pwr_prior_to_adc~ - 1)

@parameter delay_pre_damp_pulse = { "Время после РЧ импульса, перед импульсом демпфирования", 30, min=1, max=16777215, units="мкс" }
delay_pre_damp_pulse.comment = "Время после РЧ импульса, перед импульсом демпфирования"
delay_pre_damp_pulse.exec(delay_pre_damp_pulse~ - 1)

@section s_delays = { "Intervals" }
s_delays.append(tau);
s_delays.append(time_of_waiting);
s_delays.append(echo_aq_time);
s_delays.append(adc_window_shift_time);
s_delays.append(delay_before_rf_pulses);
s_delays.append(damp_pulse_duration);
s_delays.append(delay_for_strobes);
s_delays.append(time_blank_pwr_prior_to_adc);
s_delays.append(delay_pre_damp_pulse);

@export_param = { "TW1", var1, "mks" }


// "Задержка на обработку шума"
var delay_for_proc_noise = 3000;	// "Задержка на выполнение пакетов инструкций по обработке шума, мкс"
delay_for_proc_noise -= 1;			// min = 1700

// "Задержка на обработку сигнала"
var delay_for_proc = 1;				// "Задержка на выполнение пакетов инструкций по обработке сигнала"
delay_for_proc -= 1;				// min = 1

// "Интервал для пакета идентификации"
var delay_for_ident= 255;			// "Интервал для пакета идентификации, мкс"
delay_for_ident -= 1;				// min = 1

// "Задержка перед АЦП, мкс"
var delay_after_180 = tau~ - rf_pulse_duration_180~ - delay_pre_damp_pulse~ - damp_pulse_duration~ - echo_aq_time~/2 - 1 + adc_window_shift_time~ - time_blank_pwr_prior_to_adc~;

// "Интервал между последовательностями, мкс"
var relax_delay = time_of_waiting~ - delay_before_rf_pulses~ - delay_for_strobes~ - (time_blank_pwr_prior_to_adc~ + echo_aq_time~ + delay_for_proc_noise) * noise_windows_num~ - delay_for_proc_noise - delay_for_proc  - delay_for_ident - 200;

// "Задержка перед 180<sup>0</sup> импульсом, мкс"
var delay_after_echo_to_next_180 = tau~ - echo_aq_time~/2 - delay_for_proc - adc_window_shift_time~;

// "Первое tau, скорректированное с учетом длительности РЧ импульсов, мкс"
var tau1 = tau~ - rf_pulse_duration_90~/2 - 1;

// "Длительность последовательности РЧ-импульсов, мкс"
var seq_duration = tau1 + 2 * tau~ * echoes_num~;


//-----------------------------------------------------------------------------------------------------------
// Блок проверочных условий

@parameter pD1 = { "Проверка инетрвала [180-tau-]", 0, min=0, max=16777215 }
pD1.comment = "Параметр, индицирующий верность задания окна АЦП в части последовательности [180-tau-]. Если параметр > 0, то длительности в интевале [180-tau-] установлены правильно"
pD1.ron = true;
pD1.exec(tau~ - rf_pulse_duration_180~ - delay_pre_damp_pulse~ - damp_pulse_duration~ - echo_aq_time~/2 - 1 + adc_window_shift_time~ - time_blank_pwr_prior_to_adc~);

@parameter pD2 = { "Проверка инетрвала [-tau-180]", 0, min=0, max=16777215 }
pD2.comment = "Проверка задания окна АЦП в части последовательности [-tau-180]. Если параметр > 0, то длительности в интевале [180-tau-] установлены правильно"
pD2.ron = true;
pD2.exec(tau~ - echo_aq_time~/2 - delay_for_proc - adc_window_shift_time~);

@parameter pD3 = { "Параметр, индицирующий верность установленного периода повторения", 0, min=0, max=16777215 }
pD3.comment = "Проверка условия на правильность задания интервала повторения. Если параметр > 0, то интервал установлен правильно"
pD3.ron = true;
pD3.exec(time_of_waiting~ - delay_before_rf_pulses~ - delay_for_strobes~ - (time_blank_pwr_prior_to_adc~ + echo_aq_time~ + delay_for_proc_noise) * noise_windows_num~ - delay_for_proc_noise - delay_for_proc  - delay_for_ident - 200);

@parameter inv_time = { "Интервал между пакетами обработки", 255, min=1, max=16777215 }
inv_time.comment = "Интервал между пакетами обработки данных гамма-каротажа"
inv_time.ron = true;
inv_time.exec(1000000.0 / (time_of_waiting~ + tau~ - rf_pulse_duration_90~/2 + 2 * tau~ * echoes_num~));

@section s_checkers = { "Checkers" }
s_checkers.append(pD1);
s_checkers.append(pD2);
s_checkers.append(inv_time);


// -----------------------------------------------------------------------------------------------------------
// Проверяемые после вычислений условия
// Условия накладываются на вычисленные значения параметров перед внесением параметров в интервальную последовательность.
// Если условие не выполняется, то параметры не записываются в интервальную последовательность, и выдаётся соответствующее сообщение.
// -----------------------------------------------------------------------------------------------------------
// [Conditions]

@condition D1 = { "Проверка окна АЦП ([180-tau-])" }
D1.msg = "Устанавливаемые длительность и/или смещение окна АЦП приводят к перекрытию интервала демпфирования приёмника";
D1.hint = "Проверка устанавливаемой длительности или смещения окна АЦП ( [180-tau-] )";
D1.exec(tau~ - rf_pulse_duration_180~ - delay_pre_damp_pulse~ - damp_pulse_duration~ - echo_aq_time~/2 - 1 + adc_window_shift_time~ - time_blank_pwr_prior_to_adc~);

@condition D2 = { "Проверка окна АЦП" }
D2.msg = "Устанавливаемые длительность и/или смещение окна АЦП приводят к перекрытию интервала обработки данных АЦП с началом следующего РЧ импульса.";
D2.hint = "Проверка устанавливаемой длительности или смещения окна АЦП";
D2.exec(tau~ - echo_aq_time~/2 - delay_for_proc - adc_window_shift_time~);

@condition D3 = { "Проверка установленного периода повторения" }
D3.msg = "Установленные параметры приводят к слишком малому периоду повторения";
D3.hint = "Параметр, индицирующий верность установленного периода повторения";
D3.exec(time_of_waiting~ - delay_before_rf_pulses~ - delay_for_strobes~ - (time_blank_pwr_prior_to_adc~ + echo_aq_time~ + delay_for_proc_noise) * noise_windows_num~ - delay_for_proc_noise - delay_for_proc  - delay_for_ident - 200);


// -----------------------------------------------------------------------------------------------------------
// Блок параметров обработки сигнала
// [Processing]

// параметры оконных функций во временной области
@parameter a_t1 = { "Тип фильтра во врем. обл. 1 пос.-ти", 2, min=0, max=2 }
a_t1.comment = "Тип оконной функции во временной области для обработки сигнала в 1-ой последовательности. Значение: 0 - прямоугольная функция, 1 - гауссовая форма, 2 - бигауссовая форма."

@parameter s_t1 = { "Сдвиг фильтра во врем. обл. 1-ой пос.-ти", 0, min=-488281, max=488281, units="мкс" }
s_t1.comment = "Сдвиг оконной функции во временной области для обработки сигнала в 1-ой последовательности."
s_t1.exec(s_t1~ * (NMR_SAMPLE_FREQ + adc_frq_ofs_hz) / 500000);

@parameter w_t1 = { "Ширина фильтра во врем. обл. 1-ой пос.-ти", 50, min=1, max=16777215, units="мкс" }
w_t1.comment = "Ширина оконной функции во временной области для обработки сигнала в 1-ой последовательности."
w_t1.exec(w_t1~ * (NMR_SAMPLE_FREQ + adc_frq_ofs_hz) / 500000);

@parameter a_f1 = { "Тип фильтра в част. обл. 1 пос.-ти", 2, min=0, max=2 }
a_f1.comment = "Тип оконной функции в частотной области для обработки сигнала в 1-ой последовательности. Значение: 0 - прямоугольная функция, 1 - гауссовая форма, 2 - бигауссовая форма."

@parameter s_f1 = { "Сдвиг фильтра в част. обл. 1-ой пос.-ти", 250, min=-488281, max=488281, units="кГц" }
s_f1.comment = "Сдвиг оконной функции в частотной области для обработки сигнала в 1-ой последовательности."
s_f1.exec(s_f1~ * 1024 * 1000 / (NMR_SAMPLE_FREQ + adc_frq_ofs_hz));

@parameter w_f1 = { "Ширина фильтра в част. обл. 1-ой пос.-ти", 15, min=1, max=16777215, units="кГц" }
w_f1.comment = "Ширина оконной функции в частотной области для обработки сигнала в 1-ой последовательности."
w_f1.exec(w_f1~*1024*1000/(NMR_SAMPLE_FREQ + adc_frq_ofs_hz));



// -----------------------------------------------------------------------------------------------------------
// Блок правил расчёта временных отсчётов для принимаемых и сохраняемых массивов амплитуд
// При расчёте временных отсчётов по указанной в описании формуле индекс инкрементно увеличивается на 1.
//[Arguments]

function a_t_echo(N)
{
	var pts = new Array(N);
	for (var i = 0; i < N; ++i) { pts[i] = 2 * tau~ * (i + 1) / 1000 }
	return pts;
}
@argument t_echo = { "Time data for CPMG" }
t_echo.units = "ms";
t_echo.size = echoes_num~;
t_echo.points = a_t_echo(t_echo.size);



// ************************** Пакеты инструкций **************************************************************
// -----------------------------------------------------------------------------------------------------------
// Получение мощностного спектра шума в интервале для эхо
// [Package_001]
@proc NOISE = { "Noise sample" }
#begin(NOISE)
	INS_NOISE_PROC1(3, 0, 1, 0, 0)		// первый парметр: 0 - эмуляция шума в upp_buffer, 1 -  редуцированный сигнал		
	INS_CL_ST(0, 0)						// <-|<-|<-|<-|<-| очистка указателя стека
	INS_NO_OP(0, 0)
#end
 
// -----------------------------------------------------------------------------------------------------------
// Вычисление амплитуды полезного сигнала спинового эхо
// [Package_002]
@proc ECHO = { "Actual spin echo" }
#begin(ECHO)
	INS_SGN_PROC1(4, 0, 0, 5, 0, 0)		// | первый парметр: 0 - эмуляция СЭ c шум с S/N = 5 в upp_buffer, 1 -  редуцированный сигнал		
	INS_CL_ST(0, 0)						// |<-|<-|<-|<-|<-| очистка указателя стека
	INS_NO_OP(0, 0)
#end

// -----------------------------------------------------------------------------------------------------------
// Помещение идентификатора массива данных в буфер передачи данных
// [Package_003]
@proc IDENT1 = { "Gamma measurement" }
#begin(IDENT1)
	INS_WR_ACC_GRIX(1, 0, t_echo)		// | занесение idn=1 в group_index в структуре SummationBuffer
	INS_ACC_TO_OUTBUF(0, 0)				// | перенос данных (последовательность Карра-Парселла) из накопительного буфера в выходной буфер
	INS_GET_GAMMA(1, 210, 4)			// | измерить гамма-данные, занести в ячеёку X2
	INS_WR_X1(1, 0, inv_time)			// | запись числа типа float в ячейку X1
	INS_DO_XX_OPER(4, 0, 3, 4, 3, 4)	// | получение интенсивности
	INS_XX_TO_OUTBUF(1, 210, 4)			// | поместить содержимое ячейки X2 в выходной буффер с типом 210 (DT_GAMMA)
	INS_CL_ST(0, 0)						// |<-|<-|<-|<-|<-| очистка указателя стека
	INS_START_SDSP(0, 0)				// | старт диэлектрического прибора
	INS_NO_OP(0, 0)		
#end
	
// -----------------------------------------------------------------------------------------------------------
// Помещение данных SDSP в буфер передачи данных
// [Package_004]
@proc DIEL1 = { "SDSP data" }
#begin(DIEL1)
	INS_GET_SDSP(0, 0)					// | сбор данных диэлектрического прибора
	INS_CL_ST(0, 0)						// |<-|<-|<-|<-|<-| очистка указателя стека
	INS_NO_OP(0, 0)
#end
// ***********************************************************************************************************



// ***********************************************************************************************************
// Интервальная программа
// Структура: 
// (имя команды), (первый байт команды), (второй байт команды), (третий байт команды) – явное задание параметров команды 
// (имя команды), (имя параметра) – неявное, настраиваемое задание параметров команды; 
// -----------------------------------------------------------------------------------------------------------

// [Commands]
// Инициализация и задержка на передачу данных
// 12 * 0,4 мкс = 4,8 мкс + delay_before_rf_pulses
@comm fpga = { "FPGA program" }
#begin(fpga)
	COM_SWITCH_FRQ		probe					// параметризуемая установка набора базовых частот
	COM_SET_PA_ADDR		tx_adr					// адрес выбранного канала передающего тракта 
	COM_SET_RCV_ADDR	rx_adr					// адрес выбранного канала приемного тракта
	COM_TEST_CONF_WR	debug_adc				// установка отладочного режима АЦП, если установлен соответствующий режим
	COM_OFS01			tx_frq_ofs_hz			// установка гетеродинной частоты передатчика
	COM_OFS02			tx_frq2_ofs_hz			// установка вспомогательной частоты передатчика 
	COM_OFS03			rx_frq_ofs_hz			// установка гетеродинной частоты приёмника
	COM_OFS05			adc_frq_ofs_hz			// установка частоты дискретизации АЦП относительно базовой частоты

	COM_SET_VC_DAC_1	field					// установка тока подмагничивания
	COM_SET_VC_DAC_2	vc_dac_value			// установка напряжения на варикапах
	COM_PH_RST			0, 0, 1					// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе

	COM_ENB_DAMP		damp_rx_always_on		// включить демпфирование приёмника постоянно, если установлен режим постоянного демпфирования приёмника 

	COM_TIME			delay_before_rf_pulses	// интервал до начала фиктивного 90 град импульса , в котором выполняются команды инициализации прибора и завершается обмен данными
	COM_PROC_CONTROL_STB_3	0, 0, 1				// установления флага начала общего окна данных

// -----------------------------------------------------------------------------------------------------------
// Измерение шума
// (time_blank_pwr_prior_to_adc + echo_aq_time + delay_for_proc) * noise_windows_num

	COM_PROC_CONTROL_STB_2	0, 0, 1				// установления флага начала окна данных прибора ЯМР, измерение шума

	COM_CYCLE_OPEN		noise_windows_num		// начало цикла для измерений шума

	COM_TIME			time_blank_pwr_prior_to_adc	// интервал, необходим для отключения блоков заранее перед окном АЦП
	COM_BLANK_PWR		blank_pwr				// отключение импульсных блоков питания на время сбора данных АЦП

	COM_TIME			echo_aq_time			// интервал времени для сбора данных АЦП, равен длительности интервала оцифровки эхо
	COM_PROC_CONTROL_STB_1	0, 254, 1			// начало окна АЦП для оцифровки шума

	COM_TIME 			delay_for_proc_noise	// интервал для выполнения инструкций по обработке шума
	COM_PROC_CONTROL_STB_1	0, 1, 0				// снятие флага окна АЦП, выполнение Package_001
	COM_BLANK_PWR		0, 0, 0					// включение импульсных источников питания

	COM_CYCLE_CLOSE		0, 0, 0					// окончание цикла измерений шума
	COM_TIME			delay_for_proc_noise	// интервал для выполнения инструкций по обработке шума
	COM_PROC_CONTROL_STB_2	0, 0, 0				// сброс счётчика окон

// -----------------------------------------------------------------------------------------------------------
// формирование 90-град. РЧ импульса
// tau1
	COM_PH01			ph_90_num				// установка фазы 90 град. импульса
	COM_TIME			tau1					// интервал времени tau с поправкой на длительность импульса
	COM_RF01			rf_pulse_90				// установка счётчика и запуск 90 град. импульса

// -----------------------------------------------------------------------------------------------------------
// формирование 180-град. РЧ импульса, измерение эхо 
// (rf_pulse_duration_180 + delay_pre_damp_pulse + damp_pulse_duration + delay_after_180 + time_blank_pwr_prior_to_adc + echo_aq_time + delay_for_proc + delay_after_echo_to_next_180) * echoes_num
	COM_PROC_CONTROL_STB_2	0, 0, 1				// установления флага начала окна данных прибора ЯМР, измерение сигнала

	COM_TIME			0, 0, 0					// интервал для установки фазы РЧ импульса
	COM_CYCLE_OPEN		echoes_num				// начало цикла для эхо

	COM_PH01			ph_180_num				// установка фазы 180 град. импульса
	COM_TIME			rf_pulse_duration_180	// интервал времени на действие РЧ импульса
	COM_RF01			rf_pulse_180			// установка счётчика и запуск 180 град. импульса

	COM_TIME			delay_pre_damp_pulse	// интервал времени на задержку импульса демпфирования относительно окончания РЧ импульса

	COM_TIME			damp_pulse_duration		// интервал времени на демпфирование приёмника
	COM_ENB_DAMP		0, 0, 1					// включение демпфирования приёмника

	COM_TIME			delay_after_180			// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
	COM_ENB_DAMP		damp_rx_always_on		// отключение демпфирования приёмника, если не установлен режим постоянного демпфирования приёмника 

	COM_TIME			time_blank_pwr_prior_to_adc // интервал, необходим для отключения блоков заранее перед окном АЦП
	COM_BLANK_PWR		blank_pwr				// отключение импульсных блоков питания на время сбора данных АЦП

	COM_TIME			echo_aq_time			// интервал времени для сбора данных АЦП, равен длительности интервала оцифровки эхо
	COM_PROC_CONTROL_STB_1	0, 254, 1			// начало окна АЦП для оцифровки сигнала эхо

	COM_TIME			delay_for_proc			// интервал для выполнения инструкций по обработке сигнала эхо
	COM_PROC_CONTROL_STB_1	0, 2, 0				// снятие флага окна АЦП, выполнение Package_002
	COM_BLANK_PWR		0, 0, 0					// включение импульсных источников питания

	COM_TIME			delay_after_echo_to_next_180 // пауза до следующего РЧ импульса в цикле КПМГ

	COM_CYCLE_CLOSE		0, 0, 0					// окончание цикла измерений эхо
	COM_TIME			0, 0, 9					// длительность строба фиктивного устройства с Package_003 100 мкс
	COM_PROC_CONTROL_STB_2	0, 0, 0				// сброс счётчика окон

// -----------------------------------------------------------------------------------------------------------
// окончание временных окон действия последовательности РЧ импульсов и общего окна данных
//  delay_for_proc + delay_for_ident + 200 + delay_for_strobes + relax_delay
	COM_TIME			0, 0, 200				// задержка перед Package_003 на 1000 мкс
	COM_PROC_CONTROL_STB_1	0, 200, 1			// флаг фиктивного устройства для выполнения Package_003
	COM_TIME			delay_for_ident			
	COM_PROC_CONTROL_STB_1	0, 3, 0				// снятие флага окна АЦП, выполнение Package_003
	COM_TIME			4, 134, 160				// 1 134 160 = 100 ms
	COM_TIME			0, 0, 200				// задержка перед Package_003 на 1000 мкс
	COM_PROC_CONTROL_STB_1	0, 224, 1			// флаг фиктивного устройства для выполнения Package_004
	COM_TIME			delay_for_ident			
	COM_PROC_CONTROL_STB_1	0, 4, 0				// снятие флага окна АЦП, выполнение Package_003

	COM_TIME			delay_for_strobes		// интервал до времени отдыха на разнесение стробов, в котором выполняется сброс счетчика окон и снятие окна измерений
	COM_PROC_CONTROL_STB_3	0, 0, 0				// установления флага окончания общего окна данных, передача данных в рабочую станцию

	COM_TIME			relax_delay				// интервал до начала следующей последовательности, в котором выполняется передача данных

	COM_TIME			0, 0, 0					// интервал для команды 1 мкс
	COM_RET				0, 0, 0					// возврат в начало
#end
// ***********************************************************************************************************

