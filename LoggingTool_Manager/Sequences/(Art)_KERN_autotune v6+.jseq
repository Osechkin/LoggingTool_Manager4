// [Main]

// Описание: Стандартная активация T2, Двойная активация, Активация глин, Активация солид
// Назначение: Активация позволяет получать релаксационный спад (эхо-сигнала) при таком времени ожидания (time waiting) TW, что пластовые флюиды полностью поляризованы,
// и минимальном интервале между эхо (time between echo) Te=2*tau, при котором сводятся к минимумам эффекты диффузии на амплитуду спинового эхо.
// Посмледовательность: [[Aq(noise)]a]n-Tw1-90-tau-180-tau-Aq(echo)-tau-[180-tau-Aq(echo)-tau]a]i-90-t1-90-t2-90-t3-90-t4-90-t5-90-t6-90-Tw2-Send
// Ядро преобразования: Kij=exp(-ti/T2j) 
// Первичная цифровая обработка сигналов:
// - сигналы шума и сигналы спинового эхо измеряются;
// - вычисляются мощностные спектры шума и спиновых эхо;
// - с учётом усреднённого мощностного спектра шума вычисляются амплитуды полезного сигнала спинового эхо
// Контроль обработки данных:
// - сигнал с оконнной функцией
// - амплитудный спектр мощности спектров сигнала и шума
// Вывод данных:
// - амплитуды спинового эхо в последовательности КПМГ

main.name = "2 CPMG with 1 Clay CPMG v.6+"
main.author = "КФУ: Скирда В.Д., Александров А.А., Савинков А.В, Дорогиницкий М.М."
main.datetime = "10.10.2017 11:50"
main.description = "Стандартная активация T2, Двойная активация, Активация глин, Активация солид"


// Блок констант
// [Constants]
	
	var kHz2Num = 4294967296 / 250000											// 2^32 / (Тактовая частота DDS [кГц])
	var IF_FRQ = 1250															// Промежуточная частота приемника (кГц) (константа, задана аппаратно)
	var NMR_SAMPLE_FREQ = 5000													// Частота дискретизации (кГц) (константа, задана аппаратно)
	var echoes_max = 500
	var min_tau = 300
	var dead_time = 27

	var n_cpmg_max = 1

	//Data types
	var DT_RELAX1 = 40
	var DT_RELAX2 = 223
	var DT_RELAX3 = 113
	var DT_SOLID = 34
	var DT_T1T2 = 68
	var DT_DsT2 = 136
	var DT_2D_CUR = DT_RELAX1
	var DT_TUNE = 13
//-----------------------------------------------------------------------------------------------------------
// Блок выбора режима измерений
// [Measure]

	var st_cpmg = 1																// индекс первой КПМГ
	var n_cpmg = 0																// количество КПМГ		
	
	//	0 - включен: 1 КПМГ => 90-TW-90-tau-[180-tau-Aq-tau]n (TW=TW[1]=to_cpmg1; tau=TE[1]=tau_cpmg1; n=Necho)
	//	1 - выключен
	@parameter std_act_enb = { "Стандартная активация", "ON|OFF" }
	std_act_enb.comment = "Включить измерение КПМГ1"
	std_act_enb.uitype = "combobox"
	if (std_act_enb~ == 0) {n_cpmg = 1}
	
	var echo_enb = 0;var fourier_enb = 0;
	//	0 - выключен; 1 - включен вывод эхо
	@parameter sgn_enb = { "Сигнал эхо", "OFF|TIME|FREQ" }
	sgn_enb.comment = "Включить Сигнал Эхо"
	sgn_enb.uitype = "combobox"
	if (sgn_enb~ == 1) {echo_enb = 1}
	if (sgn_enb~ == 2) {fourier_enb = 1}
		
	@section meas = { "Режим измерений" }
	meas.append(std_act_enb)
	meas.append(sgn_enb)
	
//-----------------------------------------------------------------------------------------------------------
// Блок параметров частот
// [Frequencies]
	
	//	Смещение частоты резонанса
	@parameter tx_frq_ofs = { "Частота резонанса", 0, min=-488, max=488, units="кГц" }
	tx_frq_ofs.comment = "Смещение частоты относительно заданной базовой частоты"
	tx_frq_ofs.uitype = "spinbox"
	tx_frq_ofs.exec(tx_frq_ofs~ * kHz2Num)
	//	Смещение опорной частоты передатчика
	@parameter tx_frq2_ofs = { "Опорная частота передатчика", 0, min=-488, max=488, units="кГц" }
	tx_frq2_ofs.comment = "Смещение опорной частоты передачи относительно заданной базовой частоты"
	tx_frq2_ofs.exec(tx_frq2_ofs~ * kHz2Num)
	// Диапазон изменения частоты
	@parameter tx_frq_span = { "Диапазон изменения частоты", 100, min=-488, max=488, units="кГц"}
	tx_frq_span.comment = "Диапазон изменения частоты"
	tx_frq_span.uitype = "spinbox"
	tx_frq_span.exec(tx_frq_span~ * kHz2Num)
	//Количество точек настройки частоты
	@parameter points = { "Количество точек", 32, min=1, max=32 }
	points.comment = "Количество точек при автонастройке"
	points.uitype = "spinbox"
	var tx_frq_left = (tx_frq_ofs~ - tx_frq_span~ / 2) * kHz2Num
	var tx_frq_step_kHz = (tx_frq_span~ / points~)
	var tx_frq_step = tx_frq_step_kHz * kHz2Num
		
	@section s_freqs = { "Частоты" }
	s_freqs.append(tx_frq_ofs)
	s_freqs.append(tx_frq_span)
	s_freqs.append(points)


//-----------------------------------------------------------------------------------------------------------
// Блок параметров приемника
// [Reciever]
	
	//	Канал измерений
	@parameter channel = { "Номер канала", 1, min=1, max=1 }
	channel.comment = "выбор номера канала измерений (0 - первый канал ЯМР, 1 - второй канал ЯМР, ...)"
	channel.exec(channel~ - 1)
	//	Регулировка емкости варикапов для настройки приемного контура
	@parameter vc_dac = { "Настройка антенны", 2000, min=0, max=5000, units="мВ" }
	vc_dac.comment = "Напряжение на варикапах, мВ"
	vc_dac.uitype = "spinbox"
	vc_dac.exec(vc_dac~ * 65535 / 5000)
	//	Регулировка усиления примника
	@parameter KU = { "Усиление приемника", -11, min=-24, max=0, units="дБ"}
	KU.comment = "Коэффициент усиления приемника"
	KU.uitype = "spinbox"
	KU.exec(- KU~)
	
	@section s_rx = { "Приемник" }
	//s_probes.append(channel)
	s_rx.append(vc_dac)
	s_rx.append(KU)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров передатчика
// [RF_pulses]
	
	// Длительность 90-градусного рч-импульса
	@parameter rfp_90 = { "90<sup>0</sup> импульс. Длительность.", 15, min=0, max=1000, units="мкс" }
	rfp_90.comment = "Длительность 90<sup>0</sup> рч-импульса"
	rfp_90.exec(rfp_90~ * 10)																			// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	// Длительность 180-градусного рч-импульса
	@parameter rfp_180 = { "180<sup>0</sup> импульс. Длительность.", 30, min=0, max=1000, units="мкс" }
	rfp_180.comment = "Длительность 180<sup>0</sup> рч-импульса"
	rfp_180.exec(rfp_180~ * 10)																			// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	// Фаза x+ рч-импульса (0: +x; 90: +y; 180: -x, 270: -y)
	var ph_x_p = 0
	ph_x_p = ph_x_p * 46603.375
	// Фаза y+ рч-импульса (0: +x; 90: +y; 180: -x, 270: -y)
	var ph_y_p = 90
	ph_y_p = ph_y_p * 46603.375	
	// Инкремент фазы. Значение инкремента фазы для фазового циклирования
	var dph = 180
	dph = dph * 46603.375 																				// "град."
	
	@section s_tx = { "Передатчик" }
	s_tx.append(rfp_90)
	s_tx.append(rfp_180)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров ГМП
// [Reciever]
	
	//	Включить градиент
	@parameter gradient = { "Градиент", "OFF|ON" }
	gradient.comment = "Сотояние блока ГМП (ON - включен, OFF - выключен)"
	gradient.uitype = "combobox"
	var grad_on
	if (gradient~ == 1) {grad_on = 1} else {grad_on = 0}

	@section s_grad = { "Градиент" }
	s_grad.append(gradient)
	
//-----------------------------------------------------------------------------------------------------------
// Блок временных параметров последовательности
// [Intervals]
	
	// "Задержка перед началом измерений, мкс"
	var before_aq = 50000 - 1

	@parameter to_cpmg1 = { "Стандартная активация. TW", 125, min=50, max=16777, units="мс" }
	to_cpmg1.comment = "Время на восстановление намагниченности после измерений"
	to_cpmg1.uitype = "spinbox"
	to_cpmg1.exec(to_cpmg1~ * 1000 - 1)
		
	@parameter tau_cpmg1 = { "Стандартная активация. TAU", 400, min=300, max=16777, units="мкс" }
	tau_cpmg1.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ1"
	tau_cpmg1.uitype = "spinbox"

	@parameter to_aq_shift = { "Окно АЦП. Смещение", 23, min=1, max=16777, units="мкс" }
	to_aq_shift.comment = "Смещение окна АЦП от расчетного времени в последовательности КПМГ"
	to_aq_shift.exec(to_aq_shift~ - 1)																// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_echo_aq = { "Окно АЦП. Длительность.", 150, min=1, max=16777, units="мкс" }
	to_echo_aq.comment = "Длительность окна АЦП для регистрации сигнала спинового эхо в последовательности КПМГ"
	to_echo_aq.uitype = "spinbox"
	to_echo_aq.exec(to_echo_aq~ - 1)																// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс

	@section s_delays = { "Интервалы" }
	s_delays.append(to_cpmg1)
	s_delays.append(tau_cpmg1)
	//s_delays.append(to_aq_shift)
	//s_delays.append(to_echo_aq)
	
	function get_us(x) { return x * 1000 - 1}
	function get_to_aq_start(tau) { return (tau + to_aq_shift~ - (to_echo_aq~ / 2) - 1) }
	function get_to_next_180(tau) { return (tau - to_aq_shift~ - (to_echo_aq~ / 2) - 1) }
	function get_red_tau(tau) { return (tau - rfp_90~ / 2) }
			
	//TW
	var to_cpmg = get_us(to_cpmg1~)
	// Задержка перед АЦП, мкс
	var to_aq_start = get_to_aq_start(tau_cpmg1~)
	// Задержка перед 180<sup>0</sup> импульсом КПМГ, мкс
	var to_next_180 = get_to_next_180(tau_cpmg1~)
	// Первое tau, скорректированное, мкс
	var red_tau = get_red_tau(tau_cpmg1~)
	
	// "Интервал повторения, мкс"
	var to_data_tx = 3000000
	// "Интревал для насыщающей последовательности"
	var t1 = 200

//-----------------------------------------------------------------------------------------------------------
// Блок счетчиков
// [Counters]
	
// -----------------------------------------------------------------------------------------------------------
// Блок параметров обработки сигнала
// [Processing]
	function us2pts(dt) { return  (dt / 1000) * (NMR_SAMPLE_FREQ) * 2 }
	function kHz2pts(df) { return  (df) / (NMR_SAMPLE_FREQ) * 1024 }


	// "Метод вычитания шума"
	var proc_id = 0;																				// Методы вычитания шума: 0 - не вычитать шум, 1 - вычитать по методу В.Д., 2 - вычитать амплитудные спектры, 3 - выводить только шум, 4 - вычитать интегралы
	// "Коэфициент для первого эхо"
	var k_fe = 1000;																				// Коэфициент для первого эхо
	// "Время на вычисление"
	var to_echo_proc = 1000;																		// Время на выполнение пакетов инструкций по вычислению амплитуд эхо, мкс
	// "Время на вычисление"
	var to_echoes_proc = 20000 - 1																	// Время на выполнение пакетов инструкций по вычислению амплитуд эхо КПМГ1 и КПМГ2, мкс
	// "Длительность стробов для процессора"
	var to_strobe = 1500 - 1;																		// Длительность стробов для передачи управляющих команд от ПЛИС к процессору, мкс

	// параметры оконных функций во временной области
	// Тип фильтра во врем. обл.
	var win_type = 2;																				// Значение: 1 - прямоугольная функция, 2 - гауссовая форма, 3 - бигауссовая форма
	var time_shift = 0																				// Сдвиг оконной функции во временной области для обработки сигнала, мкс
	var time_width = 30																				// Ширина оконной функции во временной области для обработки, мкс
	var freq_shift = 1252																			// Сдвиг оконной функции в частотной области для обработки сигнала, кГц
	var freq_width = 1252																			// Ширина оконной функции в частотной области для обработки сигнала, кГц
	// перевод параметров
	time_shift = us2pts(time_shift); time_width = us2pts(time_width)
	freq_shift = kHz2pts(freq_shift); freq_width = kHz2pts(freq_width)

// -----------------------------------------------------------------------------------------------------------
// Проверяемые после вычислений условия
// Условия накладываются на вычисленные значения параметров перед внесением параметров в интервальную последовательность.
// Если условие не выполняется, то параметры не записываются в интервальную последовательность, и выдаётся соответствующее сообщение.
// -----------------------------------------------------------------------------------------------------------
// [Conditions]

	@condition D1 = { "Проверка устанавливаемой длительности или смещения окна АЦП" }
	D1.msg = "При установленном tau невозможно установить длительность и/или смещение окна АЦП";
	D1.hint = "Проверка устанавливаемой длительности или смещения окна АЦП";
	D1.exec(tau_cpmg1~ + to_aq_shift~ - (to_echo_aq~ /2));


// -----------------------------------------------------------------------------------------------------------
// Блок правил расчёта временных отсчётов для принимаемых и сохраняемых массивов амплитуд
// При расчёте временных отсчётов по указанной в описании формуле индекс инкрементно увеличивается на 1.
//[Arguments]

	function frq_X(N, step)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) { pts[i] = step * i - tx_frq_span~ / 2};
		return pts;
	}
	
	@argument tune_X = { "Отсчёты частоты" }
	tune_X.units = "kHz";
	tune_X.size = points~;
	tune_X.points = frq_X(tune_X.size, tx_frq_step_kHz);
		
// ************************** Пакеты инструкций **************************************************************
// -----------------------------------------------------------------------------------------------------------
	
	// [Package_001]
	@proc STD_ECHO = { "ECHO" }
	#begin(STD_ECHO)
		INS_NO_OP(0, 0)																							//               |                                                                                          
		INS_WIN_TIME(3, 0, win_type, time_shift, time_width)													//               | запись параметро временной оконной функции 
		INS_OPER_SE_D(0, 6)																						// <-|<-|<-|<-|<-| приведение массива данных АЦП для синала, помещение указателя на результат в буфере D0   
		INS_WR_D0_ST(0, 0)																						// <-|<-|<-|<-|D0|                                                                                          		
		INS_WR_D0_ST(0, 0)																						// <-|<-|<-|D0|D0|                                                                                          
		INS_APP_WIN_TIME(0, 0)																					// <-|<-|<-|<-|D0| применение оконной функции во временной области, (empty|D0)
		INS_WR_D0_ST(0, 0)																						// <-|<-|<-|D0|D0|
		INS_FFT(0, 0)																							// <-|<-|<-|<-|D0| преобразование Фурье                                                                     
		INS_WR_D0_ST(0, 0)																						// <-|<-|<-|D0|D0|                                                                                          
		INS_FAMPL(0, 0)																							// <-|<-|<-|<-|D0| вычисление амплитудного спектра Фурье в D0                                               
		INS_WR_D0_ST(0, 0)																						// <-|<-|<-|D0|D0|                                                                                          
		INS_SUM_REL_DAT(0, DT_TUNE)																				// <-|<-|<-|<-|D0| вычисление амплитуды по амплитудному спектру сигнала                                     
		INS_CL_ST(0, 0)																							// <-|<-|<-|<-|<-| очистка указателя стек                                                                   
		INS_NO_OP(0, 0)                                                                                                                                      
	#end
	
	// [Package_002]
	@proc TUNE = { "OUT" }
	#begin(TUNE)
		INS_WR_ACC_GRIX(1, 0, 1)																				//               | занесение idn=4 в group_index в структуре SummationBuffer                                         
		INS_ACC_TO_OUTBUF(0, 0)																					//               | перенос данных (последовательность Карра-Парселла) из накопительного буфера в выходной буфер      
		INS_NO_OP(0, 0)																							//               |                                                                                                   
	#end
	
// ***********************************************************************************************************


// ***********************************************************************************************************
// Интервальная программа
// Структура: 
// (имя команды), (первый байт команды), (второй байт команды), (третий байт команды) – явное задание параметров команды 
// (имя команды), (имя параметра) – неявное, настраиваемое задание параметров команды; 
// -----------------------------------------------------------------------------------------------------------

// [Commands]
// Инициализация и задержка на передачу данных
@comm fpga = { "FPGA program" }
#begin(fpga)
	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Инициализация канала channel
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
				
		COM_TIME 0, 1, 255								// интервал для SPI
		COM_SWITCH_FRQ channel							// установка базовых частот канала ЯМР
		COM_OFS01 tx_frq_ofs							// установка гетеродинной частоты передатчика
		COM_OFS02 tx_frq2_ofs							// установка вспомогательной частоты передатчика 
		COM_OFS03 tx_frq_ofs							// установка гетеродинной частоты приёмника
		COM_PH_RST 0, 0, 0								// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_SET_VC_DAC_2 vc_dac							// установка напряжения на варикапах
		COM_TIME 0, 1, 255								// интервал для SPI
		COM_SET_GAIN_1 KU								// установка коэффициента ослбления приемника
		COM_GRADIENT_ON grad_on							// включение градиента

		COM_TIME before_aq								// Задержка на установление режимов работы устройств
		COM_PROC_CONTROL_STB_3 0, 0, 1					// установка флага начала общего окна данных

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Автонастройка частоты. канал channel.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
				
		COM_TIME to_strobe								// интервал строба идентификации пакета
		COM_PROC_CONTROL_STB_2 0, 0, 1					// установка флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
		COM_OFS01 tx_frq_left							// установка гетеродинной частоты передатчика

		COM_CYCLE_OPEN points	
			// Насыщающая последовательность 90-градусных импульсов 
			COM_PH01 ph_x_p								// установка фазы +x рч-импульса
			var sp=6
			for (var j = sp-1; j >= 1 ; --j) 
			{  
				var interval = t1*Math.pow(2,j)
				COM_TIME interval						// интервал времени
				COM_RF01 rfp_90							// запуск pi/2 рч-импульса	
			};
			COM_TIME to_cpmg							// интервал TW (востановление намагниченности)
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса
			
			// Формирование и измерение эхо во внутреннем цикле
			// - формирование 90-град. рч-импульса
			COM_TIME red_tau							// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_PH01 ph_x_p								// установка фазы +x рч-импульса
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса
			
			// - формирование 180-град. РЧ импульса, измерение и накопление амплитуды эхо 
			
			COM_TIME to_aq_start						// интервал перед формированием эхо после импульса
			COM_PH01 ph_y_p								// установка фазы +y рч-импульса
			COM_RF01 rfp_180							// запуск pi рч-импульса
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_180						// интервал  до следующего рч-импульса в цикле КПМГ
			COM_PROC_CONTROL_STB_1 0, STD_ECHO, 0		// останов АЦП, выполнение STD_ECHO
			COM_TIME to_aq_start						// интервал tau перед началом обработки
			COM_AFS01 tx_frq_step						// установка следующего значения частоты передатчика
		COM_CYCLE_CLOSE 0, 0, 0
			
		// КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
		COM_TIME to_strobe								// интервал строба идентификации пакета
		COM_PROC_CONTROL_STB_2 0, 0, 0					// сброс счётчика окон
		COM_PROC_CONTROL_STB_1 0, 200, 1				// установка флага фиктивного устройства
		COM_TIME to_echoes_proc							// интервал рассчета амплитуд КПМГ
		COM_PROC_CONTROL_STB_1 0, TUNE, 0				// снятие флага окна АЦП, выполнение пакета TUNE
		
			
	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Передача данных.                                  [time = to_strobe + to_data_tx + 1]
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_TIME to_strobe								// интервал до времени отдыха на разнесение стробов
		COM_GRADIENT_ON 0, 0, 0							// включение градиента
		COM_PROC_CONTROL_STB_3 0, 0, 0					// установка флага окончания общего окна данных, передача данных в рабочую станцию
		COM_TIME to_data_tx								// интервал до начала следующей последовательности, в котором выполняется передача данных
		COM_TIME 0, 0, 0								// интервал для команды 1 мкс
		COM_RET 0, 0, 0									// возврат в начало

#end
// ***********************************************************************************************************

